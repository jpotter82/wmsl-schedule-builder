#!/usr/bin/env python3
"""
Softball Scheduler (CP-SAT / OR-Tools) â€” with per-team INTER overrides

Key idea:
- We explicitly generate the full list of required games ("demand") first:
  - INTRA games are generated by per-team intra targets (derived from GAMES_PER_TEAM - inter_total)
  - INTER games are generated by per-team division targets using a variable-degree bipartite generator
- Then CP-SAT assigns those games to field/time slots under hard constraints and optimizes soft preferences.

Requires:
  pip install ortools

CSV inputs (paths configurable below):
  field_availability.csv: date(YYYY-MM-DD), time(HH:MM AM/PM), field_id
  team_availability.csv:  team_id, day1, day2, ...
  blackout_dates.csv:     team_id, date(YYYY-MM-DD), [optional time(HH:MM AM/PM)]
"""

from __future__ import annotations

import csv
import math
import random
from dataclasses import dataclass
from datetime import datetime, date
from collections import defaultdict, Counter
from typing import Dict, List, Tuple, Set, Optional

from ortools.sat.python import cp_model


# ============================================================
# CONFIG (EDIT THIS)
# ============================================================

RANDOM_SEED = 42

FIELD_AVAILABILITY_CSV = "field_availability.csv"
TEAM_AVAILABILITY_CSV = "team_availability.csv"
BLACKOUTS_CSV = "blackout_dates.csv"  # accepts date-only blackouts OR date+time

GAMES_PER_TEAM = 22
HOME_GAMES_TARGET = 11

MIN_DAYS_BETWEEN = 5         # min rest days between games (except within doubleheader)
SUNDAY_WEIGHT = 5            # prefer Sunday slots (higher = more preference)

# Teams per division (IDs must match CSVs)
DIVISION_TEAMS: Dict[str, List[str]] = {
    "A": [f"A{i}" for i in range(1, 7)],   # A1..A6
    "B": [f"B{i}" for i in range(1, 7)],   # B1..B6
    "C": [f"C{i}" for i in range(1, 9)],   # C1..C8
    "D": [f"D{i}" for i in range(1, 9)],   # D1..D8
}

# Intra-division targets for divisions you want FIXED.
# For "flexible" divisions, omit them and the script will derive intra per team from inter targets.
# Your current rules:
# - A plays only A => intra 22 (fixed)
# - B plays B 2x+ and remainder vs C => choose B intra fixed at 16 (common choice) => B inter vs C = 6
# - C plays C 2x each => intra 14 (fixed) => C inter total = 8 (split between B and D unevenly)
# - D plays D 2x+ remainder vs C => intra is flexible per team (18/19) based on D inter targets.
INTRA_DIV_GAMES_FIXED: Dict[str, int] = {
    "A": 22,
    "B": 16,
    "C": 14,
    # "D": (flexible; derived per-team)
}

INTER_DIV_MAX_PER_OPPONENT = 1  # avoid repeat inter-div opponent pairings (recommended = 1)

# NEW: Per-team inter-division targets (OVERRIDES)
# - If a team is missing here, it defaults to 0 inter games vs all divisions.
# - Keys are team_id -> {division_letter: games_vs_that_division}
# NOTE: These must be globally consistent (totals on both sides must match per division pair).
INTER_TEAM_TARGETS: Dict[str, Dict[str, int]] = {
    # B: remainder vs C only (B intra fixed 16 => inter total 6)
    **{f"B{i}": {"C": 6} for i in range(1, 7)},

    # C: inter total 8 per team (since intra fixed 14). Uneven split:
    # C1..C4: B=5, D=3
    # C5..C8: B=4, D=4
    **{f"C{i}": {"B": 5, "D": 3} for i in range(1, 5)},
    **{f"C{i}": {"B": 4, "D": 4} for i in range(5, 9)},

    # D: remainder vs C only; uneven per team to match totals:
    # D1..D4: vs C = 4 (=> intra 18)
    # D5..D8: vs C = 3 (=> intra 19)
    **{f"D{i}": {"C": 4} for i in range(1, 5)},
    **{f"D{i}": {"C": 3} for i in range(5, 9)},

    # A not listed => no inter (A plays only A)
}

# Doubleheader sessions by division (1 session = 2 games)
# If you want "ONLY doubleheaders" for a division: set min=max=GAMES_PER_TEAM/2
DOUBLE_HEADERS_BY_DIV: Dict[str, Dict[str, int]] = {
    "A": {"min_sessions": 11, "max_sessions": 11},
    "B": {"min_sessions": 4,  "max_sessions": 6},
    "C": {"min_sessions": 3,  "max_sessions": 5},
    "D": {"min_sessions": 3,  "max_sessions": 5},
}

# Soft-constraint penalty weights (bigger = more important)
PENALTIES = {
    "home_away_deviation": 50,      # per game deviation from HOME_GAMES_TARGET
    "non_sunday_slot": 1,           # penalty for using non-Sunday slots
}

# Output
OUTPUT_SCHEDULE_CSV = "schedule.csv"


# ============================================================
# DATA STRUCTURES
# ============================================================

DAY_ABBR = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]


@dataclass(frozen=True)
class Slot:
    """One available field slot."""
    slot_id: int
    d: date
    time_str: str
    field_id: str
    dow: str
    is_sunday: bool
    dt_sort_key: Tuple

    @property
    def date_str(self) -> str:
        return self.d.strftime("%Y-%m-%d")


@dataclass(frozen=True)
class Game:
    """One game instance between two teams (home/away chosen by solver)."""
    game_id: int
    t1: str
    t2: str
    div1: str
    div2: str
    kind: str  # "INTRA" or "INTER"


# ============================================================
# CSV LOADERS
# ============================================================

def parse_time_key(time_str: str) -> Tuple[int, int]:
    dt = datetime.strptime(time_str.strip(), "%I:%M %p")
    return (dt.hour, dt.minute)


def load_field_availability(path: str) -> List[Slot]:
    slots: List[Slot] = []
    with open(path, newline="") as f:
        r = csv.reader(f)
        header = next(r, None)
        if not header:
            raise ValueError(f"{path}: empty file")
        for row in r:
            if not row or len(row) < 3:
                continue
            d = datetime.strptime(row[0].strip(), "%Y-%m-%d").date()
            time_str = row[1].strip()
            field_id = row[2].strip()
            dow = DAY_ABBR[d.weekday()]
            slots.append(
                Slot(
                    slot_id=len(slots),
                    d=d,
                    time_str=time_str,
                    field_id=field_id,
                    dow=dow,
                    is_sunday=(dow == "Sun"),
                    dt_sort_key=(d.toordinal(),) + parse_time_key(time_str),
                )
            )

    slots.sort(key=lambda s: (s.d.toordinal(), parse_time_key(s.time_str), s.field_id))
    slots = [
        Slot(
            slot_id=i,
            d=s.d,
            time_str=s.time_str,
            field_id=s.field_id,
            dow=s.dow,
            is_sunday=s.is_sunday,
            dt_sort_key=s.dt_sort_key,
        )
        for i, s in enumerate(slots)
    ]
    return slots


def load_team_availability(path: str) -> Dict[str, Set[str]]:
    avail: Dict[str, Set[str]] = {}
    with open(path, newline="") as f:
        r = csv.reader(f)
        _header = next(r, None)
        for row in r:
            if not row:
                continue
            team = row[0].strip()
            days = {c.strip() for c in row[1:] if c and c.strip()}
            avail[team] = days
    return avail


def load_blackouts(path: str) -> Tuple[Dict[str, Set[date]], Dict[str, Set[Tuple[date, str]]]]:
    by_date: Dict[str, Set[date]] = defaultdict(set)
    by_datetime: Dict[str, Set[Tuple[date, str]]] = defaultdict(set)

    with open(path, newline="") as f:
        r = csv.reader(f)
        _header = next(r, None)
        for row in r:
            if not row or len(row) < 2:
                continue
            team = row[0].strip()
            d = datetime.strptime(row[1].strip(), "%Y-%m-%d").date()
            t = row[2].strip() if len(row) >= 3 and row[2] else ""
            if t:
                by_datetime[team].add((d, t))
            else:
                by_date[team].add(d)

    return by_date, by_datetime


# ============================================================
# CONFIG + TARGET DERIVATION
# ============================================================

def team_division(team: str) -> str:
    return team[0].upper()


def all_teams_list() -> List[str]:
    return sorted([t for div in DIVISION_TEAMS for t in DIVISION_TEAMS[div]])


def derive_inter_targets_per_team() -> Dict[str, Dict[str, int]]:
    """
    Returns per-team dict: team -> {other_div: count}
    Teams not present default to 0.
    """
    targets: Dict[str, Dict[str, int]] = {}
    for t in all_teams_list():
        tdiv = team_division(t)
        dmap = dict(INTER_TEAM_TARGETS.get(t, {}))
        # Defensive: strip self-division
        if tdiv in dmap:
            raise ValueError(f"INTER_TEAM_TARGETS: team {t} has self-division entry {tdiv} (invalid).")
        # Defensive: no negative
        for od, c in dmap.items():
            if c < 0:
                raise ValueError(f"INTER_TEAM_TARGETS: team {t} has negative target vs {od}.")
            if od not in DIVISION_TEAMS:
                raise ValueError(f"INTER_TEAM_TARGETS: team {t} references unknown division {od}.")
        targets[t] = dmap
    return targets


def sanity_check_config_and_targets(inter_targets: Dict[str, Dict[str, int]]) -> Dict[str, int]:
    """
    Validates:
    - Each team has inter_total <= GAMES_PER_TEAM
    - Intra targets per team = GAMES_PER_TEAM - inter_total
    - Fixed INTRA divisional values match derived intra targets for those divisions
    - For each division pair (X,Y), total X->Y matches total Y->X
    - Doubleheader bounds sane

    Returns:
      intra_target_per_team[team] = games needed within its own division
    """
    teams = all_teams_list()

    # Intra targets per team derived
    intra_per_team: Dict[str, int] = {}
    for t in teams:
        itot = sum(inter_targets.get(t, {}).values())
        if itot > GAMES_PER_TEAM:
            raise ValueError(f"Team {t} has inter total {itot} > {GAMES_PER_TEAM}.")
        intra_per_team[t] = GAMES_PER_TEAM - itot

    # Fixed intra divisions must match
    for div, fixed_intra in INTRA_DIV_GAMES_FIXED.items():
        for t in DIVISION_TEAMS[div]:
            if intra_per_team[t] != fixed_intra:
                raise ValueError(
                    f"Fixed intra mismatch: {t} derived intra={intra_per_team[t]} but "
                    f"INTRA_DIV_GAMES_FIXED[{div}]={fixed_intra}."
                )

    # Intra feasibility: sum of intra degrees per division must be even
    for div, tlist in DIVISION_TEAMS.items():
        s = sum(intra_per_team[t] for t in tlist)
        if s % 2 != 0:
            raise ValueError(f"Intra degree sum for division {div} is odd ({s}); cannot form integer games.")

    # Inter totals consistency across division pairs
    divs = sorted(DIVISION_TEAMS.keys())
    total_div_pair = defaultdict(int)  # (from_div,to_div) totals
    for t in teams:
        from_div = team_division(t)
        for to_div, c in inter_targets[t].items():
            total_div_pair[(from_div, to_div)] += c

    for i in range(len(divs)):
        for j in range(i + 1, len(divs)):
            d1, d2 = divs[i], divs[j]
            a = total_div_pair[(d1, d2)]
            b = total_div_pair[(d2, d1)]
            if a != b:
                raise ValueError(
                    f"Inter totals mismatch {d1}<->{d2}: {d1}->{d2}={a} but {d2}->{d1}={b}."
                )

    # Doubleheader bounds
    for div, cfg in DOUBLE_HEADERS_BY_DIV.items():
        mn = cfg["min_sessions"]
        mx = cfg["max_sessions"]
        if mn > mx:
            raise ValueError(f"Doubleheaders bounds invalid for {div}: min_sessions > max_sessions")
        if 2 * mn > GAMES_PER_TEAM:
            raise ValueError(f"Doubleheaders impossible for {div}: min_sessions implies >{GAMES_PER_TEAM} games")

    return intra_per_team


# ============================================================
# MATCHUP DEMAND GENERATION
# ============================================================

def generate_intra_edges_variable_degrees(
    teams: List[str],
    degree_target: Dict[str, int],
    rnd: random.Random,
    max_per_opponent: Optional[int] = None,
) -> List[Tuple[str, str, str]]:
    """
    Generate intra-division games (undirected) where each team t needs degree_target[t] games.

    This supports "flexible" per-team intra counts (e.g., D1..D4=18, D5..D8=19)
    and also supports heavy intra divisions (e.g., A teams need 22 games inside A).

    max_per_opponent:
      - If None, a reasonable cap is computed and used as a guardrail.
      - This is NOT a strict league rule; it prevents greedy dead-ends.
    """
    n = len(teams)
    if n < 2:
        raise ValueError("Division must have at least 2 teams for intra scheduling.")

    need = {t: degree_target[t] for t in teams}
    if any(v < 0 for v in need.values()):
        raise ValueError("Negative intra degree target encountered.")
    if sum(need.values()) % 2 != 0:
        raise ValueError("Sum of intra degrees must be even.")

    # compute a sensible cap if not provided (allows 4/5 patterns etc.)
    if max_per_opponent is None:
        max_deg = max(need.values()) if need else 0
        max_per_opponent = math.ceil(max_deg / max(1, n - 1)) + 2

    pair_count = defaultdict(int)
    games: List[Tuple[str, str, str]] = []

    # Greedy degree-sequence pairing
    # (This is small; works well for these league sizes.)
    while True:
        remaining = [t for t in teams if need[t] > 0]
        if not remaining:
            break

        remaining.sort(key=lambda t: (-need[t], t))
        u = remaining[0]

        # Candidate opponents: need > 0 and under per-opponent cap
        candidates = [v for v in teams if v != u and need[v] > 0 and pair_count[tuple(sorted((u, v)))] < max_per_opponent]
        if not candidates:
            # last-resort: relax cap (prevents false infeasibility in edge cases)
            candidates = [v for v in teams if v != u and need[v] > 0]
            if not candidates:
                raise RuntimeError(f"Intra generation stuck: team {u} still needs {need[u]} but no candidates remain.")

        rnd.shuffle(candidates)
        candidates.sort(key=lambda v: (pair_count[tuple(sorted((u, v)))], -need[v], v))

        v = candidates[0]
        p = tuple(sorted((u, v)))
        pair_count[p] += 1
        need[u] -= 1
        need[v] -= 1
        games.append((u, v, "INTRA"))

    return games


def generate_bipartite_edges_variable_degrees(
    left_teams: List[str],
    right_teams: List[str],
    left_targets: Dict[str, int],
    right_targets: Dict[str, int],
    max_per_opponent: int,
    rnd: random.Random,
) -> List[Tuple[str, str]]:
    """
    Replacement for generate_bipartite_edges().

    Build bipartite edges with VARIABLE per-node degrees:

      left_targets[u]  = # games u must play vs right side
      right_targets[v] = # games v must play vs left side

    Constraints:
      - Sum(left_targets) must equal Sum(right_targets)
      - max_per_opponent is usually 1 for inter-division play

    Returns list of (u,v) pairs (one per game).
    """
    # Copy needs
    L_need = {u: int(left_targets.get(u, 0)) for u in left_teams}
    R_need = {v: int(right_targets.get(v, 0)) for v in right_teams}

    if any(x < 0 for x in L_need.values()) or any(x < 0 for x in R_need.values()):
        raise ValueError("Negative bipartite degree target encountered.")

    total_L = sum(L_need.values())
    total_R = sum(R_need.values())
    if total_L != total_R:
        raise ValueError(f"Bipartite totals mismatch: left={total_L} right={total_R}")

    pair_count = defaultdict(int)
    edges: List[Tuple[str, str]] = []

    # We'll repeatedly pick the most constrained node on the side with more remaining structure.
    # Greedy works well for your size/caps.
    left_order = left_teams[:]
    right_order = right_teams[:]
    rnd.shuffle(left_order)
    rnd.shuffle(right_order)

    while True:
        remaining_left = [u for u in left_order if L_need[u] > 0]
        remaining_right = [v for v in right_order if R_need[v] > 0]
        if not remaining_left and not remaining_right:
            break
        if not remaining_left or not remaining_right:
            raise RuntimeError("Bipartite construction stuck: one side still has needs but the other doesn't.")

        # pick left node with highest remaining need
        remaining_left.sort(key=lambda u: (-L_need[u], u))
        u = remaining_left[0]

        candidates = [v for v in right_order if R_need[v] > 0 and pair_count[(u, v)] < max_per_opponent]
        if not candidates:
            # No candidate within cap => infeasible under max_per_opponent
            raise RuntimeError(
                f"No feasible inter opponent for {u}. "
                f"Remaining need={L_need[u]}, cap={max_per_opponent}. "
                f"Consider relaxing INTER_DIV_MAX_PER_OPPONENT or targets."
            )

        rnd.shuffle(candidates)
        candidates.sort(key=lambda v: (-R_need[v], v))  # use up high-need rights

        v = candidates[0]
        edges.append((u, v))
        pair_count[(u, v)] += 1
        L_need[u] -= 1
        R_need[v] -= 1

    return edges


def generate_all_games(rnd: random.Random) -> List[Game]:
    """
    Creates the list of Game objects (unordered teams) with solver-decided home/away later.

    Uses:
      - per-team inter targets (INTER_TEAM_TARGETS)
      - derived per-team intra targets (GAMES_PER_TEAM - inter_total)
    """
    inter_targets = derive_inter_targets_per_team()
    intra_per_team = sanity_check_config_and_targets(inter_targets)

    raw_pairs: List[Tuple[str, str, str]] = []

    # 1) INTRA games per division (supports variable per-team intra)
    for div, teams in DIVISION_TEAMS.items():
        degree_target = {t: intra_per_team[t] for t in teams}
        raw_pairs.extend(generate_intra_edges_variable_degrees(teams, degree_target, rnd))

    # 2) INTER games per division-pair using variable-degree bipartite generation
    divs = sorted(DIVISION_TEAMS.keys())
    for i in range(len(divs)):
        for j in range(i + 1, len(divs)):
            d1, d2 = divs[i], divs[j]
            left = DIVISION_TEAMS[d1]
            right = DIVISION_TEAMS[d2]

            # Per-team targets for this pair
            left_targets = {u: inter_targets[u].get(d2, 0) for u in left}
            right_targets = {v: inter_targets[v].get(d1, 0) for v in right}

            if sum(left_targets.values()) == 0 and sum(right_targets.values()) == 0:
                continue

            edges = generate_bipartite_edges_variable_degrees(
                left_teams=left,
                right_teams=right,
                left_targets=left_targets,
                right_targets=right_targets,
                max_per_opponent=INTER_DIV_MAX_PER_OPPONENT,
                rnd=rnd,
            )
            for u, v in edges:
                raw_pairs.append((u, v, "INTER"))

    # Convert to Game list
    games: List[Game] = []
    for gid, (a, b, kind) in enumerate(raw_pairs):
        games.append(
            Game(
                game_id=gid,
                t1=a,
                t2=b,
                div1=team_division(a),
                div2=team_division(b),
                kind=kind,
            )
        )

    # Final sanity: each team exactly GAMES_PER_TEAM
    cnt = Counter()
    for g in games:
        cnt[g.t1] += 1
        cnt[g.t2] += 1

    for t in all_teams_list():
        if cnt[t] != GAMES_PER_TEAM:
            raise RuntimeError(f"Demand generation error: team {t} has {cnt[t]} games, expected {GAMES_PER_TEAM}")

    return games


# ============================================================
# BUILD SOLVER MODEL
# ============================================================

def build_feasible_slots_for_game(
    game: Game,
    slots: List[Slot],
    team_avail: Dict[str, Set[str]],
    blackout_by_date: Dict[str, Set[date]],
    blackout_by_dt: Dict[str, Set[Tuple[date, str]]],
) -> List[int]:
    tA, tB = game.t1, game.t2
    availA = team_avail.get(tA, set(DAY_ABBR))
    availB = team_avail.get(tB, set(DAY_ABBR))
    bdateA = blackout_by_date.get(tA, set())
    bdateB = blackout_by_date.get(tB, set())
    bdtA = blackout_by_dt.get(tA, set())
    bdtB = blackout_by_dt.get(tB, set())

    feasible = []
    for s in slots:
        if s.dow not in availA or s.dow not in availB:
            continue
        if s.d in bdateA or s.d in bdateB:
            continue
        if (s.d, s.time_str) in bdtA or (s.d, s.time_str) in bdtB:
            continue
        feasible.append(s.slot_id)
    return feasible


def solve_schedule(
    games: List[Game],
    slots: List[Slot],
    team_avail: Dict[str, Set[str]],
    blackout_by_date: Dict[str, Set[date]],
    blackout_by_dt: Dict[str, Set[Tuple[date, str]]],
) -> Tuple[Dict[int, int], Dict[int, int]]:
    model = cp_model.CpModel()

    all_teams = all_teams_list()

    # Group slots by (date, time) and by date (for adjacency)
    slots_by_datetime: Dict[Tuple[date, str], List[int]] = defaultdict(list)
    times_by_date: Dict[date, List[str]] = defaultdict(list)
    for s in slots:
        slots_by_datetime[(s.d, s.time_str)].append(s.slot_id)
        if s.time_str not in times_by_date[s.d]:
            times_by_date[s.d].append(s.time_str)
    for d in times_by_date:
        times_by_date[d].sort(key=parse_time_key)

    # Precompute slot adjacency pairs (date, time_i -> time_{i+1})
    adjacency_pairs: List[Tuple[date, str, str]] = []
    for d, tlist in times_by_date.items():
        for i in range(len(tlist) - 1):
            adjacency_pairs.append((d, tlist[i], tlist[i + 1]))

    # Decision vars: x[g,s] for feasible slots only
    x: Dict[Tuple[int, int], cp_model.IntVar] = {}
    feasible_slots_for_game: Dict[int, List[int]] = {}

    home_is_t1: Dict[int, cp_model.IntVar] = {}
    games_for_slot: Dict[int, List[cp_model.IntVar]] = defaultdict(list)

    # team_time[(team, date, time)] = BoolVar (team plays at that datetime)
    team_time: Dict[Tuple[str, date, str], cp_model.IntVar] = {}

    for g in games:
        feasible = build_feasible_slots_for_game(g, slots, team_avail, blackout_by_date, blackout_by_dt)
        if not feasible:
            raise RuntimeError(f"No feasible slots for game {g.game_id}: {g.t1} vs {g.t2}")
        feasible_slots_for_game[g.game_id] = feasible

        for s_id in feasible:
            var = model.NewBoolVar(f"x_g{g.game_id}_s{s_id}")
            x[(g.game_id, s_id)] = var
            games_for_slot[s_id].append(var)

        model.Add(sum(x[(g.game_id, s_id)] for s_id in feasible) == 1)
        home_is_t1[g.game_id] = model.NewBoolVar(f"home_is_t1_g{g.game_id}")

    # Slot occupancy
    for s in slots:
        if games_for_slot[s.slot_id]:
            model.Add(sum(games_for_slot[s.slot_id]) <= 1)

    # Build team_time vars + "one game per date/time (regardless of field)"
    # IMPORTANT: The current construction loops over all games; can be optimized later if needed.
    for team in all_teams:
        for (d, t) in slots_by_datetime.keys():
            involved_vars = []
            for g in games:
                if g.t1 != team and g.t2 != team:
                    continue
                for s_id in slots_by_datetime[(d, t)]:
                    if (g.game_id, s_id) in x:
                        involved_vars.append(x[(g.game_id, s_id)])
            if not involved_vars:
                continue
            tt = model.NewBoolVar(f"teamtime_{team}_{d}_{t}".replace(" ", ""))
            team_time[(team, d, t)] = tt
            model.Add(sum(involved_vars) == tt)

    # Minimum rest days (except within doubleheader)
    if MIN_DAYS_BETWEEN > 0:
        for team in all_teams:
            team_keys = [(d, t) for (tm, d, t) in team_time.keys() if tm == team]
            team_keys.sort(key=lambda k: (k[0].toordinal(), parse_time_key(k[1])))

            for i in range(len(team_keys)):
                d1, t1 = team_keys[i]
                for j in range(i + 1, len(team_keys)):
                    d2, t2 = team_keys[j]
                    if d1 == d2:
                        continue
                    day_diff = abs((d2 - d1).days)
                    if day_diff < MIN_DAYS_BETWEEN:
                        model.Add(team_time[(team, d1, t1)] + team_time[(team, d2, t2)] <= 1)
                    else:
                        break

    # Doubleheader session vars
    dh_session: Dict[Tuple[str, date, str], cp_model.IntVar] = {}
    for team in all_teams:
        for (d, t1, t2) in adjacency_pairs:
            if (team, d, t1) not in team_time or (team, d, t2) not in team_time:
                continue
            a = team_time[(team, d, t1)]
            b = team_time[(team, d, t2)]
            dh = model.NewBoolVar(f"dh_{team}_{d}_{t1}".replace(" ", ""))
            dh_session[(team, d, t1)] = dh
            model.Add(dh <= a)
            model.Add(dh <= b)
            model.Add(dh >= a + b - 1)

    # At most 2 games per date, and if 2 they must be adjacent
    for team in all_teams:
        for d, tlist in times_by_date.items():
            time_vars = [team_time[(team, d, t)] for t in tlist if (team, d, t) in team_time]
            if not time_vars:
                continue
            model.Add(sum(time_vars) <= 2)

            dh_vars = [dh_session[(team, d, t)] for t in tlist if (team, d, t) in dh_session]
            if dh_vars:
                model.Add(sum(dh_vars) >= sum(time_vars) - 1)
            else:
                model.Add(sum(time_vars) <= 1)

    # Prevent same opponent twice on same date (covers "different opponent in doubleheader")
    games_between: Dict[Tuple[str, str], List[int]] = defaultdict(list)
    for g in games:
        u, v = sorted((g.t1, g.t2))
        games_between[(u, v)].append(g.game_id)

    slots_by_date: Dict[date, List[int]] = defaultdict(list)
    for s in slots:
        slots_by_date[s.d].append(s.slot_id)

    for (u, v), g_ids in games_between.items():
        for d, s_ids in slots_by_date.items():
            vars_on_d = []
            for gid in g_ids:
                for sid in s_ids:
                    if (gid, sid) in x:
                        vars_on_d.append(x[(gid, sid)])
            if vars_on_d:
                model.Add(sum(vars_on_d) <= 1)

    # Doubleheader min/max sessions per team by division
    for team in all_teams:
        div = team_division(team)
        mn = DOUBLE_HEADERS_BY_DIV[div]["min_sessions"]
        mx = DOUBLE_HEADERS_BY_DIV[div]["max_sessions"]
        team_dh_vars = [v for (tm, _, _), v in dh_session.items() if tm == team]
        if team_dh_vars:
            model.Add(sum(team_dh_vars) >= mn)
            model.Add(sum(team_dh_vars) <= mx)
        else:
            if mn > 0:
                raise RuntimeError(
                    f"Team {team} requires doubleheaders but no adjacent timeslots exist in field availability."
                )

    # Home/away deviation (soft)
    home_games = {t: [] for t in all_teams}
    for g in games:
        h = home_is_t1[g.game_id]
        home_games[g.t1].append(h)
        inv = model.NewIntVar(0, 1, f"home_is_t2_g{g.game_id}")
        model.Add(inv + h == 1)
        home_games[g.t2].append(inv)

    objective_terms = []
    for t in all_teams:
        hg = model.NewIntVar(0, GAMES_PER_TEAM, f"home_count_{t}")
        model.Add(hg == sum(home_games[t]))
        dev = model.NewIntVar(0, GAMES_PER_TEAM, f"home_dev_{t}")
        model.AddAbsEquality(dev, hg - HOME_GAMES_TARGET)
        objective_terms.append(PENALTIES["home_away_deviation"] * dev)

    # Sunday preference: penalize non-Sunday usage
    for (gid, sid), var in x.items():
        if not slots[sid].is_sunday:
            objective_terms.append(PENALTIES["non_sunday_slot"] * var)

    model.Minimize(sum(objective_terms))

    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = 120.0
    solver.parameters.num_search_workers = 8
    solver.parameters.random_seed = RANDOM_SEED

    status = solver.Solve(model)
    if status not in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        raise RuntimeError(f"No feasible schedule found. Solver status: {solver.StatusName(status)}")

    game_to_slot: Dict[int, int] = {}
    home_flag: Dict[int, int] = {}

    for g in games:
        feasible = feasible_slots_for_game[g.game_id]
        chosen = None
        for sid in feasible:
            if solver.Value(x[(g.game_id, sid)]) == 1:
                chosen = sid
                break
        if chosen is None:
            raise RuntimeError(f"Internal error: game {g.game_id} not assigned")
        game_to_slot[g.game_id] = chosen
        home_flag[g.game_id] = solver.Value(home_is_t1[g.game_id])

    return game_to_slot, home_flag


# ============================================================
# VALIDATION + OUTPUT
# ============================================================

def build_dh_sessions_from_solution(
    games: List[Game],
    slots: List[Slot],
    game_to_slot: Dict[int, int],
) -> Tuple[Dict[Tuple[str, date], List[Tuple[str, str]]], Dict[int, Optional[str]]]:
    team_date_times: Dict[str, Dict[date, List[str]]] = defaultdict(lambda: defaultdict(list))
    for g in games:
        s = slots[game_to_slot[g.game_id]]
        team_date_times[g.t1][s.d].append(s.time_str)
        team_date_times[g.t2][s.d].append(s.time_str)

    team_date_sessions: Dict[Tuple[str, date], List[Tuple[str, str]]] = defaultdict(list)
    for team, dmap in team_date_times.items():
        for d, times in dmap.items():
            uniq = sorted(set(times), key=parse_time_key)
            if len(uniq) == 2:
                t1, t2 = uniq
                all_times = sorted({sl.time_str for sl in slots if sl.d == d}, key=parse_time_key)
                if t1 in all_times and t2 in all_times:
                    i1 = all_times.index(t1)
                    i2 = all_times.index(t2)
                    if abs(i2 - i1) == 1:
                        team_date_sessions[(team, d)].append(
                            (min(t1, t2, key=parse_time_key), max(t1, t2, key=parse_time_key))
                        )

    game_id_to_session: Dict[int, Optional[str]] = {g.game_id: None for g in games}
    session_counter = 1
    for (team, d), sessions in sorted(team_date_sessions.items(), key=lambda k: (k[0][0], k[0][1].toordinal())):
        for (t1, t2) in sessions:
            sid_str = f"DH{session_counter:03d}_{team}_{d.strftime('%Y%m%d')}"
            session_counter += 1
            for g in games:
                s = slots[game_to_slot[g.game_id]]
                if s.d != d:
                    continue
                if s.time_str not in (t1, t2):
                    continue
                if team in (g.t1, g.t2):
                    game_id_to_session[g.game_id] = sid_str

    return team_date_sessions, game_id_to_session


def validate_solution(
    games: List[Game],
    slots: List[Slot],
    game_to_slot: Dict[int, int],
    home_flag: Dict[int, int],
    team_avail: Dict[str, Set[str]],
    blackout_by_date: Dict[str, Set[date]],
    blackout_by_dt: Dict[str, Set[Tuple[date, str]]],
) -> None:
    teams = all_teams_list()

    # Slot occupancy
    used = Counter(game_to_slot.values())
    for sid, c in used.items():
        if c > 1:
            raise ValueError(f"Slot {sid} used by {c} games")

    # Team not double-booked same date+time
    team_dt = defaultdict(int)
    for g in games:
        s = slots[game_to_slot[g.game_id]]
        team_dt[(g.t1, s.d, s.time_str)] += 1
        team_dt[(g.t2, s.d, s.time_str)] += 1
    for k, c in team_dt.items():
        if c > 1:
            raise ValueError(f"Team double-booked at date+time: {k} count={c}")

    # Availability & blackouts
    for g in games:
        s = slots[game_to_slot[g.game_id]]
        for team in (g.t1, g.t2):
            if s.dow not in team_avail.get(team, set(DAY_ABBR)):
                raise ValueError(f"Team {team} scheduled on unavailable day {s.dow} at {s.date_str} {s.time_str}")
            if s.d in blackout_by_date.get(team, set()):
                raise ValueError(f"Team {team} scheduled on blackout date {s.date_str}")
            if (s.d, s.time_str) in blackout_by_dt.get(team, set()):
                raise ValueError(f"Team {team} scheduled on blackout datetime {s.date_str} {s.time_str}")

    # Games per team
    played = Counter()
    home_ct = Counter()
    away_ct = Counter()
    for g in games:
        played[g.t1] += 1
        played[g.t2] += 1
        if home_flag[g.game_id] == 1:
            home, away = g.t1, g.t2
        else:
            home, away = g.t2, g.t1
        home_ct[home] += 1
        away_ct[away] += 1

    for t in teams:
        if played[t] != GAMES_PER_TEAM:
            raise ValueError(f"Team {t} has {played[t]} games (expected {GAMES_PER_TEAM})")

    # MIN_DAYS_BETWEEN (except same-day)
    if MIN_DAYS_BETWEEN > 0:
        team_dates = defaultdict(list)
        for g in games:
            s = slots[game_to_slot[g.game_id]]
            team_dates[g.t1].append(s.d)
            team_dates[g.t2].append(s.d)
        for t, ds in team_dates.items():
            ds_sorted = sorted(ds)
            for i in range(len(ds_sorted)):
                for j in range(i + 1, len(ds_sorted)):
                    if ds_sorted[i] == ds_sorted[j]:
                        continue
                    if abs((ds_sorted[j] - ds_sorted[i]).days) < MIN_DAYS_BETWEEN:
                        raise ValueError(f"Team {t} violates MIN_DAYS_BETWEEN between {ds_sorted[i]} and {ds_sorted[j]}")


def write_schedule_csv(
    games: List[Game],
    slots: List[Slot],
    game_to_slot: Dict[int, int],
    home_flag: Dict[int, int],
    game_to_dh_session_id: Dict[int, Optional[str]],
    out_path: str,
) -> None:
    rows = []
    for g in games:
        s = slots[game_to_slot[g.game_id]]
        if home_flag[g.game_id] == 1:
            home, away = g.t1, g.t2
        else:
            home, away = g.t2, g.t1
        dh_id = game_to_dh_session_id.get(g.game_id)
        is_dh = "Y" if dh_id else "N"
        rows.append((
            s.d,
            parse_time_key(s.time_str),
            s.field_id,
            s.date_str,
            s.time_str,
            s.field_id,
            home,
            away,
            team_division(home),
            team_division(away),
            is_dh,
            dh_id or "",
        ))

    rows.sort(key=lambda r: (r[0].toordinal(), r[1], r[2]))

    with open(out_path, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow([
            "date", "time", "field_id",
            "home_team", "away_team",
            "home_div", "away_div",
            "is_doubleheader", "dh_session_id"
        ])
        for _d, _tk, _field, date_str, time_str, field_id, home, away, hdiv, adiv, is_dh, dh_id in rows:
            w.writerow([date_str, time_str, field_id, home, away, hdiv, adiv, is_dh, dh_id])


def print_summary(
    games: List[Game],
    slots: List[Slot],
    game_to_slot: Dict[int, int],
    home_flag: Dict[int, int],
    team_date_sessions: Dict[Tuple[str, date], List[Tuple[str, str]]],
) -> None:
    teams = all_teams_list()

    total = Counter()
    home_ct = Counter()
    away_ct = Counter()
    intra = Counter()
    inter = Counter()
    sunday_games = Counter()

    for g in games:
        s = slots[game_to_slot[g.game_id]]
        total[g.t1] += 1
        total[g.t2] += 1
        if g.kind == "INTRA":
            intra[g.t1] += 1
            intra[g.t2] += 1
        else:
            inter[g.t1] += 1
            inter[g.t2] += 1
        if s.is_sunday:
            sunday_games[g.t1] += 1
            sunday_games[g.t2] += 1

        if home_flag[g.game_id] == 1:
            home, away = g.t1, g.t2
        else:
            home, away = g.t2, g.t1
        home_ct[home] += 1
        away_ct[away] += 1

    dh_sessions_per_team = Counter()
    for (team, _d), sess in team_date_sessions.items():
        dh_sessions_per_team[team] += len(sess)

    print("\n=== SUMMARY (per team) ===")
    print("team  div  total  home  away  intra  inter  DH_sessions  Sun_games")
    for t in teams:
        print(
            f"{t:<4}  {team_division(t):<3}  {total[t]:<5}  {home_ct[t]:<4}  {away_ct[t]:<4}  "
            f"{intra[t]:<5}  {inter[t]:<5}  {dh_sessions_per_team[t]:<10}  {sunday_games[t]:<8}"
        )


# ============================================================
# MAIN
# ============================================================

def main() -> None:
    rnd = random.Random(RANDOM_SEED)

    slots = load_field_availability(FIELD_AVAILABILITY_CSV)
    team_avail = load_team_availability(TEAM_AVAILABILITY_CSV)
    blackout_by_date, blackout_by_dt = load_blackouts(BLACKOUTS_CSV)

    games = generate_all_games(rnd)

    game_to_slot, home_flag = solve_schedule(games, slots, team_avail, blackout_by_date, blackout_by_dt)

    team_date_sessions, game_to_dh_session_id = build_dh_sessions_from_solution(games, slots, game_to_slot)

    validate_solution(games, slots, game_to_slot, home_flag, team_avail, blackout_by_date, blackout_by_dt)

    write_schedule_csv(games, slots, game_to_slot, home_flag, game_to_dh_session_id, OUTPUT_SCHEDULE_CSV)
    print(f"\nWrote: {OUTPUT_SCHEDULE_CSV}")

    print_summary(games, slots, game_to_slot, home_flag, team_date_sessions)


if __name__ == "__main__":
    main()
